
This document is a summary of each class in the montecarlo library

How to read: every function here starts with a `>` before its name

===============================================================================================================================

DataSimulator
    >simulate_one(PDF* p): returns a single value out of a PDF with the statistical properties of that PDF
    >simulate_sample(vector<PDF*>* vp): returns a vector of values as above


ErrorPropagator
    abstract class for propagating errors: derivate classes must reimplement function `f`

    constructor: ErrorPropagator(v): `v` is a vector<PDF*>*
    >f(): it is the function of the variables whose PDFs are in the vector passed to the constructor
    >propagation(n,seed,min,max,steps,name): builds a PDF by `n` iterations between `min` and `max` with `steps` steps and name `name`


LinearFit
    this object can both work with internal or external vectors. To work with internal vector just omitt the data vectors in every function.
    To fill the internal vectors you can use both the `>add` function or `>set_data`

    >fit(file_name,start_line,end_line): builds the PDFs of the parameters of the line y = a + b*x interpolating data in `filename`
					 in lines [`start_line` : `end_line`]. To obtain those PDFs use functions `getA()` and `getB()`
    >fit(xV,yVP): `xV` is a vector<double>* and `yVP` is a vector<PDF*>*
					it does the same thing of the previous, but picking up data from the vectors

    >intersec(file_name1,file_name2): returns a PDF** containing the PDFs (`ix` and `iy`) of the x and y coordinates of the intersection between the interpolating lines of `file_name1` and `file_name2`
    >intersec(file_name,a,b): returns a PDF** containing the PDFs of the x and y coordinates of the intersection between the interpolating line of `file_name` and 
			      y = a + b*x

    >add(input,xV,yVP): this is a VERY USEFUL routine of the LinearFit object: `input` is an ifstream*, `xV` is a vector<double>*
			and `yVP` is a vector<PDF*>*. This functions adds data `xV` `yVP` reading from a file that has to be in the following
			file format.
			To use this function you will only need to setPrecision, so you can use it also for initializing data in a ParametricFit

   >chi2(xV,yVP): returns the chi square
   >rho(xV,yVP): returns Bravais-Pearson correlation coefficient
   >T_N(): returns the value for the T_student associated with rho
    
    File format:
	x_value		yPDF_type	yPDF_a		yPDF_b
	
	    yPDF_type =
		      "Uniform"	 		-> yPDF_a = min,	yPDF_b = max
		      "Triangular"		-> yPDF_a = center,	yPDF_b = full width
		      "Gauss"			-> yPDF_a = mean,	yPDF_b = sigma
		      "Digital"			-> yPDF_a = value	yPDF_b = digit		yPDF_c = gain
		      "Oscilloscope"		-> yPDF_a = V,		yPDF_b = Vdiv                 it considers a contribute of 3% gain + 0.05*Vdiv of digits
 		      
    Settings:
	>setAB_steps(n)	-> set the number of steps of the `a`,`b`,`ix`,`iy` PDFs
	>setPrecision(n)	-> set the number of steps of the PDFs of the simulated sample
	>setN(n)		-> set the number of iterations
	
    Further settings:
	to use the function `fit`:
	    >setA_range(m,M)	-> set min and max value for the `a` PDF
	    >setB_range(m,M)	-> set min and max value for the `b` PDF
	    
	to use the function `intersec`:
	    >setIX_range(m,M)	-> set min and max value for the `ix` PDF
	    >setIY_range(m,M)	-> set min and max value for the `iy` PDF
	

PDFFactory
    abstract class for building PDFs

    >create(min,max,steps,name): creates a PDF between `min` and `max` with `steps` steps and name `name` using a generic function `f` that is reimplemented in derived classes
    >create_default(steps): create a PDF with `steps` steps, this function is reimplemented in every derived class
    
    derived classes
	GaussFactory(mean,sigma): builds gaussians
		default gaussian are created in [mean - 5*sigma : mean + 5*sigma]
	UniformFactory(a,b): builds a uniform distribution between `a` and `b`
		default uniforms are created in [a,b]
	TriangularFactory(center,fullwidth): builds triangular distributions
		default triangulars are created in [`center` - `fullwidth`/2 : center + `fullwidth`/2]
	DigitalFactory(center,digit,gain): builds a PDF resulting from a measurement with a digital instrument
		with errors due to `digit` and `gain` (this one is a percentage, e.g.: 0.03)
		default digitals are created where they are non 0
		This PDFs are created via a propagation of two uniform distributions
		

PDFFactoryManager
    >create(PDF_type,PDFa,PDFb): creates a PDFFactory with type `PDF_type` and parameters `PDF_a` and `PDF_b`
				
				see LinearFit -> File Format -> yPDF_type

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STANDARD  WAY OF BUILDING PDFs via a PDFFactory

PDFFactory* F = PDFFactoryManager::create(PDF_type,PDFa,PDFb);
PDF* pdf = F->create(min,max,steps,name);
delete F;

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

